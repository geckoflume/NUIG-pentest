#!/usr/bin/env python3
from os.path import splitext, basename
from subprocess import run, TimeoutExpired, PIPE, STDOUT

from tests.test import Test

title = 'Traceroute to the Internet'
desc = 'The board will attempt to traceroute to [www.google.com](http://www.google.com).'
vulnerability = 'This is a form of reconnaissance that allows the user to map out the network topology inside the ' \
                'target infrastructure.'
exploit = 'Although there is not a direct exploit for this vulnerability, the information yielded can be used in  ' \
          'more advanced tests later. An understanding of the target network topology will allow more focussed ' \
          'attacks against the IT infrastructure.'
countermeasure = 'It is difficult to prevent traceroute within the internal network without using IEEE 802.1x port ' \
                 'authentication or ACLs (Access Control Lists) on the routers and\/or switches. To prevent ' \
                 'traceroute traffic that traverses the firewall you should note that, by default, UDP port 33434 is ' \
                 'used as the base port number. Each additional routing hop increments the UDP port by +1 â€“ ' \
                 'therefore routing hop 2 uses UDP port 33435, routing hop 3 uses UDP port 33436, etc. Although ' \
                 'firewall rules can be configured to restrict this access based on the UDP information provided, ' \
                 'the default port(s) can be easily changed by the user.'


class Traceroute(Test):
    def __init__(self):
        Test.__init__(self)
        self.title = title
        self.desc = desc
        self.vulnerability = vulnerability
        self.exploit = exploit
        self.countermeasure = countermeasure
        self.filename = splitext(basename(__file__))[0] + ".md"
        self.run()

    def run(self):
        try:
            proc = run(["traceroute", "-I", Test.interface.name, "www.google.com"], stdout=PIPE, stderr=STDOUT,
                       timeout=120)
        except TimeoutExpired as e:
            self.results = e.stdout.decode()
            self.code = 1
        else:
            self.results = proc.stdout.decode()
            self.code = proc.returncode

        self.build_report()
        self.end()
